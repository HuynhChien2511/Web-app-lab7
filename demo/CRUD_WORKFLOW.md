# Lab 7 Exercises 5-8 Workflow Documentation

## Exercise 5: Advanced Search Workflow

### 5.1 Multi-Criteria Search
Access localhost:8080/products, the user can see an "Advanced Search" section with input fields for name, category dropdown, minimum price, and maximum price. When the user fills in any combination of these fields and clicks "Apply Filters" button, the browser sends a GET request to /products/advanced-search with query parameters (name, category, minPrice, maxPrice). The controller layer receives the request and calls the service layer method advancedSearch() passing all four parameters. The service layer then calls productRepository.searchProducts() which executes a custom @Query that uses conditional WHERE clauses with "IS NULL OR" logic to handle optional parameters. At the database level, it executes SQL with dynamic filtering: WHERE (:name IS NULL OR name LIKE %:name%) AND (:category IS NULL OR category = :category) AND price conditions. The results are returned as a list, passed back through service to controller, added to the model, and the product-list view renders the filtered products in the table for the user.

### 5.2 Category Filter
Access localhost:8080/products, the user sees a dropdown labeled "Filter by Category" populated with all unique categories from the database. When the user selects a category from the dropdown, JavaScript auto-submits the form sending a GET request to /products?category=Electronics. The controller layer receives the category parameter in listProducts() method and calls productService.getProductsByCategory(category). The service layer calls productRepository.findByCategory() which is a Spring Data JPA derived query method. At the database level, it executes "SELECT * FROM products WHERE category = ?" to retrieve only products matching that category. The filtered list is returned through service layer to controller, added to model along with all available categories, and the view displays the filtered results with the selected category highlighted in the dropdown for user feedback.

### 5.3 Search with Pagination
Access localhost:8080/products, the user enters a keyword in the search box and clicks the search button. The browser sends a GET request to /products/search?keyword=Laptop&page=0&size=10. The controller layer receives the keyword, page number (default 0), and page size (default 10) parameters, then calls productService.searchProducts(keyword, pageable) where pageable is created using PageRequest.of(page, size). The service layer calls productRepository.findByNameContaining(keyword, pageable) which returns a Page<Product> object. At the database level, Spring Data JPA executes "SELECT * FROM products WHERE name LIKE %keyword% LIMIT 10 OFFSET 0" along with a count query to get total records. The Page object containing products, total pages, total elements, and current page number is returned to controller, which extracts the content and pagination metadata, adds them to model (products, currentPage, totalPages, totalItems), and the view renders the product table with pagination controls showing Previous/Next buttons and numbered page links at the bottom for user navigation.

---

## Exercise 6: Validation Workflow

### 6.1 & 6.2 Server-Side Validation
Access localhost:8080/products/new, the user sees a form with empty fields for product code, name, price, quantity, category, and description. When the user fills in the form with invalid data (e.g., product code "AB123" instead of "P123", price "-10", or empty required fields) and clicks "Save" button, the browser sends a POST request to /products/save with form data. The controller layer receives the request in saveProduct() method where the Product parameter is annotated with @Valid and followed by a BindingResult parameter. Spring automatically validates the Product entity against all validation annotations (@NotBlank, @Size, @Pattern, @DecimalMin, @DecimalMax, @Min) defined in the Product class. If validation fails, errors are captured in the BindingResult object, and the controller checks result.hasErrors() - if true, it returns "product-form" view name without saving. The validation framework checks each field: productCode must match pattern "^P\\d{3,}$", name must be 3-100 characters, price must be between 0.01 and 999999.99, quantity cannot be negative, and category cannot be blank. No database interaction occurs when validation fails, and the form is redisplayed with the invalid data still populated in fields for user correction.

### 6.3 Display Validation Errors
When validation fails and the form view is returned, Thymeleaf processes the template with the BindingResult containing all field errors. For each input field, the th:errorclass="error" attribute checks if that field has errors using #fields.hasErrors('fieldName') - if true, it adds the "error" CSS class which applies a red border to the input field. Below each input field, a <span> element with th:if="${#fields.hasErrors('fieldName')}" conditionally renders only if that specific field has validation errors. The th:errors="*{fieldName}" attribute extracts the validation error message (e.g., "Product code must start with P followed by numbers") from the BindingResult and displays it in the span with the "error-message" CSS class, which renders the text in red color at 12px font size. The user sees immediate visual feedback: invalid fields have red borders, and specific error messages appear below each problematic field explaining what went wrong. The user can then correct the errors and resubmit - when all validations pass (result.hasErrors() returns false), the controller proceeds to call productService.saveProduct(product), which calls productRepository.save() to persist the validated data to the database, then redirects to /products with a success message.

---

## Exercise 7: Sorting and Filtering Workflow

### 7.1 Sorting
Access localhost:8080/products, the user sees a table with column headers for Code, Name, Price, Quantity, and Category - each header is a clickable link. When the user clicks on the "Price" header, the browser sends a GET request to /products?sortBy=price&sortDir=asc. The controller layer receives these parameters in listProducts() method, checks if sortBy is not null, then creates a Sort object using Sort.by(sortBy).ascending() or .descending() based on sortDir parameter. The controller calls productService.getAllProducts(sort) passing the Sort object. The service layer calls productRepository.findAll(sort) which is a built-in JpaRepository method that accepts Sort parameter. At the database level, Spring Data JPA executes "SELECT * FROM products ORDER BY price ASC" to retrieve all products sorted by the specified column and direction. The sorted list is returned through service to controller, added to model along with sortBy and sortDir for maintaining state, and the view renders the sorted table with an arrow indicator (↑ for ascending, ↓ for descending) next to the active sorted column header. Each column header link includes logic to toggle sortDir: if currently ascending, the link sets it to descending and vice versa, allowing users to reverse sort order by clicking the same header again.

### 7.2 & 7.3 Combined Sorting and Filtering
Access localhost:8080/products, the user first selects "Electronics" from the category filter dropdown, which sends GET request to /products?category=Electronics. The controller receives the category parameter, calls productService.getProductsByCategory(category), and displays filtered results. Then, while the category filter is active, the user clicks the "Price" header to sort. The browser sends GET request to /products?category=Electronics&sortBy=price&sortDir=asc with both parameters. The controller's listProducts() method has conditional logic: it first checks if category parameter exists and is not empty - if true, it calls getProductsByCategory() to filter by category; if sortBy also exists, it cannot directly apply sort to the category-filtered list from the derived query method, so the implementation filters first then the view maintains the category selection. The view displays the filtered and sorted results, with the category dropdown showing "Electronics" as selected (using th:selected="${cat == selectedCategory}") and the Price column header showing the sort arrow. The model includes both selectedCategory and sortBy/sortDir attributes so the view can render appropriate visual feedback, and all links preserve both parameters - category filter links include current sortBy/sortDir, and sort header links include current category, ensuring the combined state is maintained across user interactions.

---

## Exercise 8: Statistics Dashboard Workflow

### 8.1 Statistics Methods
Access localhost:8080/dashboard, the browser sends a GET request to the server. The controller layer DashboardController receives the request in showDashboard() method and begins gathering statistics by calling multiple service methods. First, it calls productService.getAllProducts().size() to count total products. For category statistics, it calls productService.getAllCategories() to get unique category list, then loops through each category calling productService.countByCategory(category) which executes the @Query "SELECT COUNT(p) FROM Product p WHERE p.category = :category" at database level, storing results in a HashMap. It calls productService.calculateTotalValue() which executes @Query "SELECT SUM(p.price * p.quantity) FROM Product p" to calculate total inventory value, with null-safe handling returning BigDecimal.ZERO if result is null. It calls productService.calculateAveragePrice() executing @Query "SELECT AVG(p.price) FROM Product p" for average price calculation. It calls productService.findLowStockProducts(10) which executes @Query "SELECT p FROM Product p WHERE p.quantity < :threshold ORDER BY p.quantity ASC" to retrieve products with quantity less than 10. Finally, it calls productService.getRecentProducts() which uses derived query method findTop5ByOrderByCreatedAtDesc() executing "SELECT * FROM products ORDER BY created_at DESC LIMIT 5" to get the 5 most recently added products. All these statistics are added to the model as separate attributes.

### 8.2 & 8.3 Dashboard View
After the controller adds all statistics to the model (totalProducts, totalValue, averagePrice, lowStockCount, categoryStats map, lowStockProducts list, recentProducts list, categories list), it returns the view name "dashboard". The Thymeleaf template engine processes dashboard.html, accessing model attributes using ${} expressions. The view renders four statistics cards at the top: Total Products card displays ${totalProducts}, Total Inventory Value card displays ${totalValue} formatted as currency using ${#numbers.formatDecimal(totalValue, 1, 2)} with dollar sign prefix, Average Price card displays ${averagePrice} similarly formatted, and Low Stock Items card displays ${lowStockCount}. Below that, the Products by Category section uses th:each="cat : ${categories}" to iterate through all categories, and for each one displays the category name ${cat} and its count from the map ${categoryStats.get(cat)} in a grid layout. The Low Stock Alerts section checks th:if="${lowStockProducts != null and !lowStockProducts.isEmpty()}" - if true, it renders a warning alert and a table using th:each="product : ${lowStockProducts}" to display each low-stock product's code, name, quantity (shown in a red badge), category, and price; if false, it shows a green checkmark message "All products adequately stocked". The Recent Products section similarly checks if recentProducts list is not empty, then renders a table with th:each="product : ${recentProducts}" displaying code, name, category, price, quantity, and formatted creation timestamp using ${#temporals.format(product.createdAt, 'yyyy-MM-dd HH:mm')}. The entire dashboard uses CSS with gradient background, hover effects on cards, color-coded sections, and a "Back to Products" link at the top for navigation, providing the user with a comprehensive visual overview of all inventory statistics and alerts.

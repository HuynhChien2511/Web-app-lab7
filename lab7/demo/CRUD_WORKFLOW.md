# Product Management System - CRUD Workflow Documentation

## ğŸ“‹ Table of Contents
1. [Architecture Overview](#architecture-overview)
2. [CREATE Workflow](#create-workflow)
3. [READ Workflow](#read-workflow)
4. [UPDATE Workflow](#update-workflow)
5. [DELETE Workflow](#delete-workflow)
6. [SEARCH Workflow](#search-workflow)
7. [Layer Responsibilities](#layer-responsibilities)
8. [Request Flow Diagram](#request-flow-diagram)

---

## ğŸ—ï¸ Architecture Overview

This project follows the **Layered Architecture** pattern with Spring Boot, which is a fundamental design principle that separates concerns into distinct layers. Each layer has a specific responsibility and communicates only with adjacent layers, creating a clean and maintainable codebase.

### Why Layered Architecture?

**1. Separation of Concerns:** Each layer focuses on a single responsibility, making the code easier to understand and maintain.

**2. Testability:** You can test each layer independently. For example, you can test the service layer without involving the database by mocking the repository.

**3. Reusability:** Service methods can be reused by multiple controllers or even external APIs.

**4. Maintainability:** Changes in one layer don't cascade to other layers. For instance, switching from MySQL to PostgreSQL only affects the configuration, not the business logic.

**5. Scalability:** You can optimize or scale specific layers independently based on performance needs.

### The Five-Layer Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           PRESENTATION LAYER                â”‚
â”‚  (ProductController - @Controller)          â”‚
â”‚  - Handles HTTP requests                    â”‚
â”‚  - Returns views (Thymeleaf)                â”‚
â”‚  - Validates user input                     â”‚
â”‚  - Manages flash messages                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ Calls service methods
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            SERVICE LAYER                    â”‚
â”‚     (ProductServiceImpl - @Service)         â”‚
â”‚  - Business logic & validation              â”‚
â”‚  - Transaction management (@Transactional)  â”‚
â”‚  - Orchestrates multiple repository calls   â”‚
â”‚  - Error handling & logging                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ Calls repository methods
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         REPOSITORY LAYER                    â”‚
â”‚  (ProductRepository - @Repository)          â”‚
â”‚  - Data access operations (CRUD)            â”‚
â”‚  - Custom query methods                     â”‚
â”‚  - Auto-generated by Spring Data JPA        â”‚
â”‚  - No SQL code needed!                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ Maps to/from Entity
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ENTITY LAYER                      â”‚
â”‚         (Product - @Entity)                 â”‚
â”‚  - Represents database table structure      â”‚
â”‚  - JPA annotations for mapping              â”‚
â”‚  - Validation constraints                   â”‚
â”‚  - Lifecycle callbacks (@PrePersist)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ JDBC Connection
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           DATABASE (MySQL)                  â”‚
â”‚         Table: products                     â”‚
â”‚  - Stores persistent data                   â”‚
â”‚  - Enforces constraints (PK, FK, UNIQUE)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### How Data Flows Through the Layers

**Downward Flow (Request):**
1. Browser sends HTTP request â†’ **Controller** receives it
2. Controller extracts data â†’ calls **Service** method
3. Service applies business logic â†’ calls **Repository** method
4. Repository uses **Entity** mapping â†’ generates SQL
5. SQL executes on **Database** â†’ returns result

**Upward Flow (Response):**
1. Database returns rows â†’ **Repository** receives ResultSet
2. JPA maps rows to **Entity** objects â†’ returns to Service
3. Service processes data â†’ returns to Controller
4. Controller adds data to Model â†’ returns view name
5. Thymeleaf renders HTML â†’ Browser displays page

### Spring Boot's Magic: Dependency Injection

Spring Boot automatically creates and manages instances of each layer:
- `@Controller` â†’ Spring creates ProductController instance
- `@Service` â†’ Spring creates ProductServiceImpl instance
- `@Repository` â†’ Spring generates ProductRepository implementation

These are connected through **constructor injection**, where Spring automatically provides the required dependencies when creating objects. This means you don't use `new ProductService()` anywhere â€“ Spring handles it!

---

## ğŸ†• CREATE Workflow

### Understanding the Two-Phase Create Process

Creating a product involves **two separate HTTP requests**:
1. **GET request** - Displays the empty form
2. **POST request** - Submits the filled form data

This follows the **PRG Pattern (Post-Redirect-Get)**, which prevents duplicate submissions if the user refreshes the page.

---

### Phase 1: Displaying the Form (GET)

**Step 1: User clicks "Add New Product" button**

When you click this button, your browser sends a GET request to: `http://localhost:8080/products/new`

**Why GET?** Because you're just requesting to view the form, not modifying any data yet. GET requests are safe and idempotent (repeating them doesn't change anything).

---

**Step 2: Controller Layer (`ProductController`) - Preparing the Form**

```java
@GetMapping("/new")
public String showNewForm(Model model) {
    Product product = new Product();
    model.addAttribute("product", product);
    return "product-form";  // Show empty form
}
```

**What's happening here?**

- `@GetMapping("/new")` - Maps the URL `/products/new` to this method
- `new Product()` - Creates an **empty** Product object with null/default values
- `model.addAttribute("product", product)` - Adds this empty object to the Model
- **Why add an empty object?** The form uses Thymeleaf's `th:object="${product}"` to bind form fields. Even for a new product, we need an object for the binding to work.
- `return "product-form"` - Tells Spring to render `product-form.html`

**The Model:** Think of the Model as a box that carries data from the controller to the view. We put the empty Product object in this box, and Thymeleaf will use it to generate the form.

---

**Step 3: View Layer (`product-form.html`) - Rendering the Form**

Thymeleaf processes the template and generates HTML:

```html
<form th:action="@{/products/save}" th:object="${product}" method="post">
    <input type="text" th:field="*{productCode}" />
    <input type="text" th:field="*{name}" />
    <!-- ... more fields ... -->
</form>
```

**How Thymeleaf works here:**

- `th:object="${product}"` - Binds the form to the Product object we sent from the controller
- `th:field="*{productCode}"` - Creates an input field bound to `product.productCode`
  - The `*{}` syntax means "access property of the bound object"
  - Generates: `<input type="text" id="productCode" name="productCode" value="" />`
- When the form is new, all fields are empty because our Product object has no values yet

**Result:** Your browser displays an empty form with fields for Product Code, Name, Price, Quantity, Category, and Description.

---

### Phase 2: Submitting the Form (POST)

**Step 4: User fills form and clicks "Save Product"**

You enter values:
- Product Code: "P006"
- Name: "Wireless Mouse"
- Price: 29.99
- Quantity: 100
- Category: "Electronics"
- Description: "Ergonomic wireless mouse"

When you click "Save Product", the browser sends a POST request to: `http://localhost:8080/products/save`

**Form data in the request:**
```
productCode=P006
name=Wireless Mouse
price=29.99
quantity=100
category=Electronics
description=Ergonomic wireless mouse
```

**Why POST?** Because we're creating new data, which modifies the server state. POST is the appropriate HTTP method for data creation.

---

**Step 5: Controller Layer (POST) - Receiving Form Data**

```java
@PostMapping("/save")
public String saveProduct(@ModelAttribute("product") Product product, 
                         RedirectAttributes redirectAttributes) {
    productService.saveProduct(product);
    redirectAttributes.addFlashAttribute("message", "Product added successfully!");
    return "redirect:/products";
}
```

**The magic of `@ModelAttribute`:**

Spring automatically converts the form data into a Product object:
1. Spring sees `@ModelAttribute("product")`
2. It creates a new `Product()` object
3. For each form field, it calls the corresponding setter:
   - `product.setProductCode("P006")`
   - `product.setName("Wireless Mouse")`
   - `product.setPrice(new BigDecimal("29.99"))`
   - etc.
4. It passes this populated Product object to the method

**No manual parsing needed!** Spring handles all the HTTP parameter extraction and type conversion.

**Why `RedirectAttributes`?**

Flash attributes are stored temporarily (in session) and survive a redirect. After saving, we redirect to the product list, and the success message appears there. This is crucial for the PRG pattern.

---

**Step 6: Service Layer (`ProductServiceImpl`) - Business Logic**

```java
@Transactional
@Override
public Product saveProduct(Product product) {
    // In a real application, you might add validation here:
    // - Check if product code already exists
    // - Validate price is positive
    // - Check stock quantity is reasonable
    
    return productRepository.save(product);  // Delegate to repository
}
```

**Why have a service layer?**

Even though this method just calls the repository, in real applications you would:
- Validate business rules (e.g., "Product code must be unique")
- Calculate derived values (e.g., "Apply 10% discount if quantity > 100")
- Coordinate multiple repository calls (e.g., "Save product AND update inventory")
- Log important business events

**The `@Transactional` annotation:**

This ensures that if anything goes wrong (exception thrown), all database changes are **rolled back**. It's like having an "undo" button for database operations.

---

**Step 7: Repository Layer (`ProductRepository`) - Data Persistence**

```java
// JpaRepository provides save() method automatically
// Spring Data JPA generates SQL: INSERT INTO products (...)
```

**How Spring Data JPA works:**

1. You call `productRepository.save(product)`
2. JPA checks: "Does this Product have an ID?"
   - **If ID is null** â†’ This is a NEW product â†’ Execute INSERT
   - **If ID exists** â†’ This is an UPDATE â†’ Execute UPDATE
3. JPA examines the Product entity's annotations to build SQL
4. JPA executes the SQL and returns the saved Product (now with an auto-generated ID)

**No SQL code required!** Spring generates it based on your entity annotations.

---

**Step 8: Entity Layer (`Product`) - Lifecycle Callback**

```java
@PrePersist
protected void onCreate() {
    this.createdAt = LocalDateTime.now();  // Set timestamp before insert
}
```

**What is `@PrePersist`?**

This is a **JPA lifecycle callback** that executes automatically right before the entity is inserted into the database. 

**Why use it?**

You don't want to manually set `createdAt` every time you create a product. This callback ensures the timestamp is **always** set automatically, preventing human error.

**Other lifecycle callbacks available:**
- `@PreUpdate` - Before updating
- `@PostPersist` - After inserting
- `@PostLoad` - After loading from database

---

**Step 9: Database - SQL Execution**

JPA generates and executes:
```sql
INSERT INTO products 
  (product_code, name, price, quantity, category, description, created_at) 
VALUES 
  ('P006', 'Wireless Mouse', 29.99, 100, 'Electronics', 'Ergonomic wireless mouse', '2025-11-26 14:30:00');
```

**Auto-increment magic:**

Notice we didn't provide an ID. The database automatically generates it (e.g., ID = 6) because the `id` column is defined as `AUTO_INCREMENT`. JPA then updates the Product object with this generated ID.

**Result in database:**

| id | product_code | name | price | quantity | category | description | created_at |
|----|--------------|------|-------|----------|----------|-------------|------------|
| 6 | P006 | Wireless Mouse | 29.99 | 100 | Electronics | Ergonomic wireless mouse | 2025-11-26 14:30:00 |

---

**Step 10: Response - Redirect with Success Message**

The controller returns `"redirect:/products"`, which tells the browser:
1. Send a **new GET request** to `/products`
2. The flash message "Product added successfully!" is stored in the session
3. The browser redirects and loads the product list
4. The success message is displayed once and then removed

**Why redirect instead of directly showing the list?**

This is the **Post-Redirect-Get (PRG) pattern**:
- **Without PRG:** If you refresh the page, the browser resends the POST request â†’ duplicate product created!
- **With PRG:** After redirect, refreshing only reloads the product list (GET request) â†’ safe!

**Final Result:** You see the product list with your new "Wireless Mouse" product, and a green success message at the top.

### ğŸ“Œ CREATE Workflow Conclusion

The CREATE operation demonstrates Spring Boot's elegant handling of form submissions through a two-phase process. The initial GET request prepares an empty form with data binding, while the POST request leverages Spring's `@ModelAttribute` to automatically convert HTTP parameters into a Java objectâ€”eliminating manual parsing entirely. The `@PrePersist` lifecycle callback ensures timestamps are set automatically, and JPA intelligently determines this is an INSERT operation (not UPDATE) because the Product ID is null. Finally, the PRG pattern (Post-Redirect-Get) prevents duplicate submissions by redirecting after successful creation, making the workflow both user-friendly and robust against common web application pitfalls.

---

## ğŸ‘ï¸ READ Workflow

### Understanding Data Retrieval and Display

The READ operation is the most fundamental CRUD operation. It's what happens when you simply want to view data without modifying it. This workflow demonstrates how Spring Boot efficiently retrieves data from MySQL and displays it as an HTML table.

---

**Step 1: User navigates to products page**

You type `http://localhost:8080/products` in your browser or click a "Products" link. Your browser sends a **GET request** to the server.

**Why GET?** GET requests are designed for retrieving data. They're:
- **Safe**: Don't modify server state
- **Idempotent**: Can be repeated without side effects
- **Cacheable**: Browsers can cache the response
- **Bookmarkable**: You can save the URL and come back later

---

**Step 2: Controller Layer - Orchestrating the Request**

```java
@GetMapping
public String listProducts(Model model) {
    List<Product> products = productService.getAllProducts();
    model.addAttribute("products", products);
    return "product-list";  // Returns product-list.html
}
```

**Breaking it down:**

1. `@GetMapping` with no path parameter means this handles requests to the base URL `/products`
2. `Model model` is injected by Spring - it's the data container we'll pass to the view
3. `productService.getAllProducts()` calls the service layer to fetch data
4. `model.addAttribute("products", products)` adds the product list to the model with key "products"
   - Think of this as: `model.put("products", products)` in a Map
5. `return "product-list"` tells Spring to find and render `product-list.html`

**Why not return the products directly?** Because this is a web application returning HTML, not a REST API returning JSON. We need a template to format the data as HTML.

---

**Step 3: Service Layer - Business Logic Gateway**

```java
@Override
public List<Product> getAllProducts() {
    return productRepository.findAll();  // Get all products
}
```

**Why does this seem too simple?**

In this basic example, the service just passes the call to the repository. However, in real applications, the service layer might:

- **Apply business rules**: "Only show products with quantity > 0"
- **Aggregate data**: "Calculate total inventory value"
- **Cache results**: "Cache product list for 5 minutes to reduce DB load"
- **Transform data**: "Convert prices to user's currency"
- **Security checks**: "Only show products user has permission to view"

The service layer exists to keep the controller thin and handle complex business scenarios.

---

**Step 4: Repository Layer - The Data Access Abstraction**

```java
// JpaRepository provides findAll() automatically
// Spring Data JPA generates: SELECT * FROM products
```

**The magic of Spring Data JPA:**

You didn't write `findAll()` - Spring generated it! When you extend `JpaRepository<Product, Long>`, you automatically get:

- `findAll()` - Get all records
- `findById(Long id)` - Get one by ID
- `save(Product)` - Insert or update
- `delete(Product)` - Delete a record
- `count()` - Count all records
- `existsById(Long id)` - Check if exists
- And 15+ more methods!

**How does Spring know which table to query?**

It looks at the `Product` entity class, which has `@Table(name = "products")`, and generates: `SELECT * FROM products`

---

**Step 5: Database - Executing the Query**

MySQL executes:
```sql
SELECT id, product_code, name, price, quantity, category, description, created_at 
FROM products;
```

The database returns a **ResultSet** containing all rows:

```
+----+--------------+-------------------+---------+----------+--------------+
| id | product_code | name              | price   | quantity | category     |
+----+--------------+-------------------+---------+----------+--------------+
| 1  | P001         | Laptop Dell XPS   | 1299.99 | 10       | Electronics  |
| 2  | P002         | iPhone 15 Pro     | 999.99  | 25       | Electronics  |
| 3  | P003         | Samsung Galaxy    | 899.99  | 20       | Electronics  |
+----+--------------+-------------------+---------+----------+--------------+
```

---

**Step 6: Entity Mapping - From Database Rows to Java Objects**

**How JPA converts rows to objects:**

For each row in the ResultSet, JPA:

1. Creates a new `Product` object: `new Product()`
2. Reads column values and calls setters:
   - `product.setId(1L)`
   - `product.setProductCode("P001")`
   - `product.setName("Laptop Dell XPS")`
   - `product.setPrice(new BigDecimal("1299.99"))`
   - etc.
3. Adds the Product to a `List<Product>`

**Type conversions handled automatically:**
- Database `BIGINT` â†’ Java `Long`
- Database `VARCHAR` â†’ Java `String`
- Database `DECIMAL(10,2)` â†’ Java `BigDecimal`
- Database `INT` â†’ Java `Integer`
- Database `TIMESTAMP` â†’ Java `LocalDateTime`

**Result:** You get a `List<Product>` with 3 Product objects, ready to use in Java.

---

**Step 7: View Layer - Rendering HTML with Thymeleaf**

```html
<tr th:each="product : ${products}">
    <td th:text="${product.id}">1</td>
    <td th:text="${product.productCode}">P001</td>
    <td th:text="${product.name}">Product Name</td>
    <td th:text="'$' + ${#numbers.formatDecimal(product.price, 1, 2)}">$99.99</td>
    <td th:text="${product.quantity}">10</td>
    <td th:text="${product.category}">Electronics</td>
    <!-- Edit and Delete buttons -->
</tr>
```

**How Thymeleaf processes this:**

1. `th:each="product : ${products}"` - Loops through the products list
   - Similar to: `for (Product product : products) { ... }`
   - Creates one `<tr>` for each product

2. `th:text="${product.id}"` - Calls `product.getId()` and puts the value in the `<td>`
   - Replaces the placeholder "1" with the actual ID

3. `${#numbers.formatDecimal(product.price, 1, 2)}` - Formats the price
   - `1` = minimum integer digits
   - `2` = exactly 2 decimal places
   - Converts `1299.99` to "1299.99" (not "1299.9" or "1299.990")

**The power of Natural Templates:**

Notice the placeholder values ("1", "P001", "Product Name")? These make the HTML look realistic when you open it directly in a browser without running the server. Thymeleaf replaces them with real data at runtime.

---

**Step 8: Response - Delivering HTML to Browser**

Thymeleaf generates the final HTML:

```html
<tr>
    <td>1</td>
    <td>P001</td>
    <td>Laptop Dell XPS</td>
    <td>$1299.99</td>
    <td>10</td>
    <td>Electronics</td>
    <td><a href="/products/edit/1">Edit</a></td>
    <td><a href="/products/delete/1">Delete</a></td>
</tr>
<tr>
    <td>2</td>
    <td>P002</td>
    <td>iPhone 15 Pro</td>
    <td>$999.99</td>
    <td>25</td>
    <td>Electronics</td>
    <td><a href="/products/edit/2">Edit</a></td>
    <td><a href="/products/delete/2">Delete</a></td>
</tr>
```

This HTML is sent to your browser, which renders it as a beautiful table with clickable Edit and Delete buttons for each product.

**Performance consideration:** If you have 10,000 products, `findAll()` loads all of them into memory at once! In real applications, you'd use **pagination** to load 20-50 products at a time.

### ğŸ“Œ READ Workflow Conclusion

The READ operation showcases the power of Spring Data JPA's convention-over-configuration approach. Without writing a single line of SQL, the `findAll()` method retrieves all products from the database, automatically maps database rows to Java objects with proper type conversions, and passes them to Thymeleaf for rendering. The layered architecture shines here: the controller remains thin (just 4 lines), the service provides a clean abstraction for future enhancements, and the repository leverages JPA's auto-generated implementation. Thymeleaf's `th:each` loop and natural templates make the view code both powerful and readable, demonstrating how Spring Boot minimizes boilerplate while maximizing developer productivity.

---

## âœï¸ UPDATE Workflow

### User Action: Edit Existing Product

**1. User clicks "Edit" button on a product**
- URL: `http://localhost:8080/products/edit/1` (where 1 is product ID)
- HTTP Method: `GET`

**2. Controller Layer (GET Edit Form)**
```java
@GetMapping("/edit/{id}")
public String showEditForm(@PathVariable Long id, Model model, 
                          RedirectAttributes redirectAttributes) {
    return productService.getProductById(id)
        .map(product -> {
            model.addAttribute("product", product);
            return "product-form";  // Show form with existing data
        })
        .orElseGet(() -> {
            redirectAttributes.addFlashAttribute("error", "Product not found");
            return "redirect:/products";
        });
}
```

**3. Service Layer**
```java
@Override
public Optional<Product> getProductById(Long id) {
    return productRepository.findById(id);
}
```

**4. Repository Layer**
```java
// JpaRepository provides findById() automatically
// Spring Data JPA generates: SELECT * FROM products WHERE id = ?
```

**5. Database**
- Executes: `SELECT * FROM products WHERE id = 1`
- Returns single product record or empty result

**6. View Layer**
- Form is pre-filled with existing product data
- Hidden field contains product ID for update
- Title shows "âœï¸ Edit Product"

**7. User modifies fields and clicks "Save Product"**
- URL: `http://localhost:8080/products/save`
- HTTP Method: `POST`
- Form includes hidden ID field

**8. Controller Layer (POST)**
```java
@PostMapping("/save")
public String saveProduct(@ModelAttribute("product") Product product, 
                         RedirectAttributes redirectAttributes) {
    productService.saveProduct(product);  // ID is present, so UPDATE
    redirectAttributes.addFlashAttribute("message", "Product updated successfully!");
    return "redirect:/products";
}
```

**9. Service Layer**
```java
@Override
public Product saveProduct(Product product) {
    return productRepository.save(product);  // JPA detects ID exists -> UPDATE
}
```

**10. Repository Layer**
```java
// JPA checks if ID exists in database
// If exists: Performs UPDATE
// Spring Data JPA generates: UPDATE products SET ... WHERE id = ?
```

**11. Database**
- Executes: `UPDATE products SET product_code=?, name=?, price=?, quantity=?, category=?, description=? WHERE id=1`
- Updates existing record

**12. Response**
- Redirects to: `http://localhost:8080/products`
- Shows success message: "Product updated successfully!"
- Product list reflects updated data

### ğŸ“Œ UPDATE Workflow Conclusion

The UPDATE operation demonstrates Spring Boot's intelligent handling of the same endpoint for both creation and modification. The workflow uses two GET/POST pairs: first to retrieve and display existing data, then to submit changes. JPA's smart `save()` method detects the presence of an ID and automatically switches from INSERT to UPDATE modeâ€”no manual SQL decision-making required. The use of `Optional<Product>` in the GET phase provides elegant null-safety, ensuring users receive a clear error message if they try to edit a non-existent product. By reusing the same form template and controller method for both CREATE and UPDATE, this design exemplifies the DRY principle (Don't Repeat Yourself) while maintaining code clarity and reducing maintenance overhead.

---

## ğŸ—‘ï¸ DELETE Workflow

### User Action: Delete Product

**1. User clicks "Delete" button on a product**
- JavaScript confirmation: "Are you sure you want to delete this product?"
- URL: `http://localhost:8080/products/delete/1` (where 1 is product ID)
- HTTP Method: `GET`

**2. Controller Layer**
```java
@GetMapping("/delete/{id}")
public String deleteProduct(@PathVariable Long id, 
                           RedirectAttributes redirectAttributes) {
    try {
        productService.deleteProduct(id);
        redirectAttributes.addFlashAttribute("message", "Product deleted successfully!");
    } catch (Exception e) {
        redirectAttributes.addFlashAttribute("error", "Error deleting product: " + e.getMessage());
    }
    return "redirect:/products";
}
```

**3. Service Layer**
```java
@Override
public void deleteProduct(Long id) {
    productRepository.deleteById(id);
}
```

**4. Repository Layer**
```java
// JpaRepository provides deleteById() automatically
// Spring Data JPA generates: DELETE FROM products WHERE id = ?
```

**5. Database**
- Executes: `DELETE FROM products WHERE id = 1`
- Removes record permanently

**6. Response**
- Redirects to: `http://localhost:8080/products`
- Shows success message: "Product deleted successfully!"
- Product no longer appears in list

**Error Handling:**
- If product doesn't exist: Throws exception
- Caught in controller and displays error message

### ğŸ“Œ DELETE Workflow Conclusion

The DELETE operation prioritizes safety and user experience through multiple protective layers. JavaScript confirmation provides immediate client-side prevention of accidental deletions, while the try-catch block in the controller gracefully handles server-side errors like non-existent products or constraint violations. The `@Transactional` annotation on the service layer ensures atomicity, so in complex scenarios involving multiple table deletions, either all operations succeed or none doâ€”maintaining data integrity. Although this implementation uses a hard delete for simplicity, production systems typically employ soft deletes (setting a `deleted_at` flag) to preserve historical data and enable recovery. The redirect-with-flash-message pattern ensures users receive clear feedback while keeping the URL clean and preventing accidental re-deletion on page refresh.

---

## ğŸ” SEARCH Workflow

### User Action: Search Products

**1. User enters keyword in search box and clicks "Search"**
- URL: `http://localhost:8080/products/search?keyword=laptop`
- HTTP Method: `GET`

**2. Controller Layer**
```java
@GetMapping("/search")
public String searchProducts(@RequestParam("keyword") String keyword, Model model) {
    List<Product> products = productService.searchProducts(keyword);
    model.addAttribute("products", products);
    model.addAttribute("keyword", keyword);
    return "product-list";  // Reuse same view
}
```

**3. Service Layer**
```java
@Override
public List<Product> searchProducts(String keyword) {
    return productRepository.findByNameContaining(keyword);
}
```

**4. Repository Layer**
```java
// Custom query method - Spring Data JPA derives query from method name
List<Product> findByNameContaining(String keyword);

// Spring generates: SELECT * FROM products WHERE name LIKE %keyword%
```

**5. Database**
- Executes: `SELECT * FROM products WHERE name LIKE '%laptop%'`
- Returns matching products (case-insensitive search)

**6. View Layer**
- Displays filtered results in same product-list table
- Shows search keyword in search box
- Message: "Showing results for: laptop"

### ğŸ“Œ SEARCH Workflow Conclusion

The SEARCH operation highlights Spring Data JPA's query method derivation magic, where method names like `findByNameContaining()` are automatically translated into SQL `LIKE` queries without writing any SQL code. This approach combines the readability of natural language method names with the power of database-level filtering, ensuring searches are performed efficiently on the server rather than loading all products and filtering in memory. By reusing the same `product-list.html` template for both full listings and search results, the implementation minimizes code duplication while providing a consistent user experience. The inclusion of the search keyword in the model allows the view to display context-aware messages and maintain the search term in the input box, creating an intuitive search interface that feels responsive and professional.

---

## ğŸ“Š Layer Responsibilities

### 1. **Entity Layer** (`Product.java`)
**Responsibility:** Data structure and database mapping

**Key Features:**
- `@Entity` - Marks class as JPA entity
- `@Table(name = "products")` - Maps to database table
- `@Id` + `@GeneratedValue` - Auto-increment primary key
- `@Column` annotations - Define constraints (nullable, unique, length, precision)
- `@PrePersist` - Lifecycle callback to set `createdAt` before INSERT
- Getters/Setters for all fields
- `toString()` for logging

**Database Mapping:**
```
Java Type          â†’ Database Type
Long id            â†’ BIGINT AUTO_INCREMENT
String             â†’ VARCHAR
BigDecimal price   â†’ DECIMAL(10,2)
Integer            â†’ INT
LocalDateTime      â†’ TIMESTAMP
```

---

### 2. **Repository Layer** (`ProductRepository.java`)
**Responsibility:** Data access and query operations

**Key Features:**
- `@Repository` annotation
- Extends `JpaRepository<Product, Long>`
  - `Product` = Entity type
  - `Long` = Primary key type

**Inherited Methods (Auto-provided by Spring):**
```java
findAll()           // SELECT * FROM products
findById(Long id)   // SELECT * WHERE id = ?
save(Product p)     // INSERT or UPDATE
deleteById(Long id) // DELETE WHERE id = ?
count()            // SELECT COUNT(*) FROM products
existsById(Long id) // Check if exists
```

**Custom Query Methods (Spring derives SQL from method names):**
```java
findByCategory(String category)
// â†’ SELECT * FROM products WHERE category = ?

findByNameContaining(String keyword)
// â†’ SELECT * FROM products WHERE name LIKE %keyword%

findByPriceBetween(BigDecimal min, BigDecimal max)
// â†’ SELECT * FROM products WHERE price BETWEEN min AND max

findByCategoryOrderByPriceAsc(String category)
// â†’ SELECT * FROM products WHERE category = ? ORDER BY price ASC

existsByProductCode(String code)
// â†’ SELECT COUNT(*) > 0 FROM products WHERE product_code = ?
```

**No Implementation Needed!** Spring Data JPA generates all SQL automatically.

---

### 3. **Service Layer** (`ProductService.java` + `ProductServiceImpl.java`)
**Responsibility:** Business logic and transaction management

**Why Service Layer?**
- **Separation of Concerns:** Controller doesn't directly access repository
- **Transaction Management:** `@Transactional` ensures ACID properties
- **Business Logic:** Validation, calculations, orchestration
- **Reusability:** Service methods can be called from multiple controllers

**Key Annotations:**
- `@Service` - Marks as Spring service component
- `@Transactional` - Automatic transaction management (commit/rollback)

**Methods:**
```java
getAllProducts()           // Business logic for listing
getProductById(Long id)    // Return Optional (null-safe)
saveProduct(Product p)     // Validation before save
deleteProduct(Long id)     // Pre-delete checks
searchProducts(String kw)  // Search orchestration
getProductsByCategory()    // Category filtering
```

**Transaction Example:**
```java
@Transactional
public Product saveProduct(Product product) {
    // 1. Validation logic
    if (product.getPrice().compareTo(BigDecimal.ZERO) < 0) {
        throw new IllegalArgumentException("Price cannot be negative");
    }
    
    // 2. Business rules
    // Check for duplicate product code, calculate discounts, etc.
    
    // 3. Save to database
    return productRepository.save(product);
    
    // If exception occurs, transaction is automatically rolled back
}
```

---

### 4. **Controller Layer** (`ProductController.java`)
**Responsibility:** HTTP request handling and response

**Key Annotations:**
- `@Controller` - Marks as Spring MVC controller
- `@RequestMapping("/products")` - Base URL for all methods
- `@GetMapping` - Handle GET requests
- `@PostMapping` - Handle POST requests
- `@PathVariable` - Extract from URL (e.g., `/edit/{id}`)
- `@RequestParam` - Extract from query string (e.g., `?keyword=laptop`)
- `@ModelAttribute` - Bind form data to object

**URL Mappings:**
```
GET  /products              â†’ listProducts()
GET  /products/new          â†’ showNewForm()
GET  /products/edit/{id}    â†’ showEditForm()
POST /products/save         â†’ saveProduct()
GET  /products/delete/{id}  â†’ deleteProduct()
GET  /products/search       â†’ searchProducts()
```

**Dependency Injection:**
```java
private final ProductService productService;

@Autowired
public ProductController(ProductService productService) {
    this.productService = productService;  // Constructor injection
}
```

**Flash Attributes (Success/Error Messages):**
```java
redirectAttributes.addFlashAttribute("message", "Product added successfully!");
// Message is stored in session and available after redirect
```

---

### 5. **View Layer** (Thymeleaf Templates)
**Responsibility:** HTML rendering with dynamic data

**Templates:**
- `product-list.html` - Display all products in table
- `product-form.html` - Add/Edit product form

**Thymeleaf Syntax:**
```html
<!-- Display text -->
<td th:text="${product.name}">Product Name</td>

<!-- Loop through list -->
<tr th:each="product : ${products}">
    ...
</tr>

<!-- Conditional display -->
<div th:if="${message}" class="alert alert-success">
    <span th:text="${message}"></span>
</div>

<!-- Form binding -->
<form th:action="@{/products/save}" th:object="${product}" method="post">
    <input type="text" th:field="*{name}" />
</form>

<!-- URL generation -->
<a th:href="@{/products/edit/{id}(id=${product.id})}">Edit</a>

<!-- Format numbers -->
<td th:text="'$' + ${#numbers.formatDecimal(product.price, 1, 2)}">$99.99</td>
```

---

## ğŸ”„ Complete Request Flow Diagram

### Example: UPDATE Product Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BROWSER â”‚ User clicks "Edit" on Product ID=1
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
      â”‚ HTTP GET /products/edit/1
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductController       â”‚
â”‚  @GetMapping("/edit/{id}")â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ productService.getProductById(1)
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductServiceImpl      â”‚
â”‚  @Service @Transactional â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ productRepository.findById(1)
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductRepository       â”‚
â”‚  extends JpaRepository   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ SQL: SELECT * FROM products WHERE id = 1
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MySQL Database          â”‚
â”‚  products table          â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ Returns Product data
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Product Entity          â”‚
â”‚  JPA maps row to object  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ Optional<Product>
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductServiceImpl      â”‚
â”‚  Returns to controller   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ Optional<Product>
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductController       â”‚
â”‚  model.addAttribute()    â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ Return "product-form"
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Thymeleaf Engine        â”‚
â”‚  Renders product-form.htmlâ”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ HTML with pre-filled form
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BROWSER â”‚ Displays form with existing product data
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ User modifies name, price, etc.
      â”‚ Clicks "Save Product"
      â”‚
      â”‚ HTTP POST /products/save
      â”‚ Form Data: id=1, name="New Name", price=1299.99, ...
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductController       â”‚
â”‚  @PostMapping("/save")   â”‚
â”‚  @ModelAttribute Product â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ productService.saveProduct(product)
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductServiceImpl      â”‚
â”‚  Validates data          â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ productRepository.save(product)
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductRepository       â”‚
â”‚  JPA detects ID exists   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ SQL: UPDATE products SET name=?, price=?, ... WHERE id=1
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MySQL Database          â”‚
â”‚  Updates product record  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ Success
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ProductController       â”‚
â”‚  addFlashAttribute()     â”‚
â”‚  redirect:/products      â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ HTTP 302 Redirect
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BROWSER â”‚ Shows "Product updated successfully!"
â”‚          â”‚ Displays updated product in list
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Key Design Patterns Used

### 1. **MVC (Model-View-Controller) Pattern**
- **Model:** Product entity + Repository
- **View:** Thymeleaf templates (product-list.html, product-form.html)
- **Controller:** ProductController

### 2. **Dependency Injection**
```java
@Autowired
public ProductController(ProductService productService) {
    this.productService = productService;  // Spring injects implementation
}
```

### 3. **Repository Pattern**
- Abstract data access logic
- ProductRepository interface - Spring provides implementation

### 4. **Service Layer Pattern**
- Encapsulate business logic
- Transaction boundary

### 5. **Data Transfer**
- Form data â†’ Product object (via `@ModelAttribute`)
- Product object â†’ View (via `Model`)

---

## ğŸ“ Summary

### CRUD Operations Summary Table

| Operation | URL Pattern | HTTP Method | Controller Method | Service Method | Repository Method | SQL Generated |
|-----------|-------------|-------------|-------------------|----------------|-------------------|---------------|
| **CREATE** | `/products/new` (GET) | GET | `showNewForm()` | - | - | - |
| | `/products/save` (POST) | POST | `saveProduct()` | `saveProduct()` | `save()` | `INSERT INTO...` |
| **READ** | `/products` | GET | `listProducts()` | `getAllProducts()` | `findAll()` | `SELECT *` |
| | `/products/search` | GET | `searchProducts()` | `searchProducts()` | `findByNameContaining()` | `SELECT * WHERE name LIKE` |
| **UPDATE** | `/products/edit/{id}` (GET) | GET | `showEditForm()` | `getProductById()` | `findById()` | `SELECT * WHERE id=` |
| | `/products/save` (POST) | POST | `saveProduct()` | `saveProduct()` | `save()` | `UPDATE...WHERE id=` |
| **DELETE** | `/products/delete/{id}` | GET | `deleteProduct()` | `deleteProduct()` | `deleteById()` | `DELETE WHERE id=` |

---

## ğŸš€ Technology Stack

- **Spring Boot 3.5.8** - Application framework
- **Spring Data JPA** - Data access layer
- **Hibernate** - ORM implementation
- **MySQL 8.0** - Database
- **Thymeleaf** - Template engine
- **Maven** - Build tool
- **Java 17** - Programming language

---

## ğŸ“š Additional Features

### Auto-Configuration
Spring Boot automatically configures:
- DataSource (from `application.properties`)
- EntityManagerFactory (JPA)
- Transaction Manager
- Repository implementations
- Thymeleaf view resolver

### Transaction Management
`@Transactional` on service layer ensures:
- **Atomicity:** All or nothing
- **Consistency:** Data integrity maintained
- **Isolation:** Concurrent transactions don't interfere
- **Durability:** Committed changes are permanent

### Error Handling
```java
try {
    productService.saveProduct(product);
    redirectAttributes.addFlashAttribute("message", "Success!");
} catch (Exception e) {
    redirectAttributes.addFlashAttribute("error", "Error: " + e.getMessage());
}
```

---

**Generated by:** Product Management System Documentation  
**Date:** November 26, 2025  
**Version:** 1.0
